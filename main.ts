///////////////////////////////////////////
// Arbitrary String Construction Project //
///////////////////////////////////////////

import * as Colors from "https://deno.land/std@0.204.0/fmt/colors.ts";
import { new_stack, Stack } from "./stack.ts";

/**
 * An expression, to be evaluated to a string.
 *
 * Evaluation is not a pure function, but threads a {@linkcode Context} value
 * through the evaluation, which can be read and manipulated by the functions
 * that get called as part of evaluating certain expressions.
 *
 * Of particular importance is the {@linkcode DelayingExpression}, which can
 * delay its own evaluation based on the {@linkcode Context}. This allows for
 * sophisticated communication between expressions, as required for
 * implementing, say, a system of definitions and references.
 */
export type Expression =
  /**
   * Every string evaluates to itself.
   */
  | string
  /**
   * An array of Expression is evaluated by evaluating its subexpressions and
   * concatenating the result.
   */
  | Expression[]
  /**
   * A thunk that either produces an expression, or signals it cannot do so
   * yet. The evaluator then retries the thunk in the next evaluation round.
   */
  | DelayingExpression
  /**
   * An expression, augmented with functions that get called before and after
   * attempting its evaluation.
   */
  | LifecyclingExpression
  /**
   * An expression, augmented with a function that maps its evaluation result
   * to a completely new expression, which then gets evaluated instead.
   */
  | MappingExpression
  /**
   * An expression with debugging information. The evaluator keeps a stacktrace
   * of StacktracingExpressions. Typically autogenerated by jsx, not created by
   * hand.
   */
  | StacktracingExpression;

/**
 * A DelayingExpression is to a normal expression what an asynchronous function
 * is to a normal function. The Delaying Expression might either produce an
 * expression (which then gets evaluated in its stead), or it indicates that
 * it cannot be evaluated yet.
 *
 * When a DelayingExpression signals it could not be evaluated, the evaluator
 * simply resumes evaluating the next expression. Once no further unevaluated
 * expressions are left, the evaluator tries all DelayedExpressions again.
 *
 * If no DelayedExpressions make progress in two rounds in a row, evaluation
 * terminates unsuccessfully. The {@linkcode Context} allows the {@linkcode poll}
 * function to query whether it is currently a final evaluation attempt. An
 * appropriate response might be to emit a warning and then return some dummy
 * value, so that evaluation can proceed unhindered.
 */
export class DelayingExpression {
  /**
   * The function to determine whether evaluation can progress (when returning
   * an {@link Expression}) or needs to be retried later (when returning
   * `null`).
   */
  public poll: (ctx: Context) => Expression | null;

  constructor(poll: (ctx: Context) => Expression | null) {
    this.poll = poll;
  }
}

/**
 * Wraps an {@linkcode Expression} with functions that are called before and
 * after evaluating the expression. These functions are called purely for their
 * side-effects.
 *
 * Note that the functions might be called multiple times when the wrapped
 * expression contains a {@linkcode DelayingExpression} that need retrying.
 */
export class LifecyclingExpression {
  /**
   * The wrapped {@linkcode Expression}.
   */
  public exp: Expression;
  /**
   * Called before evaluating the inner expression.
   */
  public preEvaluate: (ctx: Context) => void;
  /**
   * Called after evaluating the inner expression.
   */
  public postEvaluate: (ctx: Context) => void;

  /**
   * @param exp The wrapped {@linkcode Expression}.
   * @param preEvaluate Sets the `pre_evaluate` function, defaults to doing
   * nothing.
   * @param postEvaluate Sets the `post_evaluate` function, defaults to doing
   * nothing.
   */
  constructor(
    exp: Expression,
    preEvaluate?: (ctx: Context) => void,
    postEvaluate?: (ctx: Context) => void,
  ) {
    this.exp = exp;
    this.preEvaluate = preEvaluate ?? ((_) => {});
    this.postEvaluate = postEvaluate ?? ((_) => {});
  }
}

/**
 * When the wrapped {@linkcode Expression} has been sucessfully evaluated to a
 * string, map that string to a new {@linkcode Expression} to evaluate next.
 */
export class MappingExpression {
  /**
   * The wrapped {@linkcode Expression}.
   */
  public exp: Expression;
  /**
   * The function to transform the fully evaluated {@linkcode exp} into a new
   * {@linkcode Expression} to then evaluate.
   */
  public map: (exp: string, ctx: Context) => Expression;

  /**
   * @param exp The {@linkcode Expression} to wrap.
   * @param map The function to transform the evaluated {@linkcode Expression}.
   */
  constructor(
    exp: Expression,
    map: (exp: string, ctx: Context) => Expression,
  ) {
    this.exp = exp;
    this.map = map;
  }
}

/**
 * Debugging information that can be attached to {@linkcode Expression}s via
 * {@linkcode StacktracingExpression}s.
 */
export interface DebuggingInformation {
  /**
   * The file in which the annotated {@linkcode Expression} was created.
   */
  file?: string;
  /**
   * The line in which the annotated {@linkcode Expression} was created.
   */
  line?: number;
  /**
   * The column in which the annotated {@linkcode Expression} was created.
   */
  column?: number;
  /**
   * The name of the function (macro) that created the annotated
   * {@linkcode Expression}.
   */
  name?: string;
}

/**
 * Style {@linkcode DebuggingInformation} for terminal output.
 * @param info The {@linkcode DebuggingInformation} to tyle
 * @returns The {@linkcode DebuggingInformation}, converted to a string with
 * pretty ansi escapes.
 */
export function formatDebuggingInformation(
  info: DebuggingInformation,
): string {
  const name = Colors.bold(Colors.italic(info.name ?? "anonymous"));
  const file = info.file ? ` in ${styleFile(info.file)}` : "";
  const position = info.file && info.line
    ? Colors.yellow(`:${info.line}${info.column ? `:${info.column}` : ""}`)
    : "";
  return `${name}${file}${position}`;
}

/**
 * Style a filename for terminal output.
 * @param s The name to style.
 * @returns The name with ansi escape sequences for styling.
 */
export function styleFile(s: string): string {
  return Colors.cyan(s);
}

/**
 * A `StacktracingExpression` wraps another {@linkcode Expression} with
 * debugging information. The evaluator keeps a stack of the debugging
 * information on the way from the evaluation entrypoint to the currently
 * evaluated expression. All functions with access to a {@linkcode Context}
 * can inspect this stack, and faild evaluation prints a stacktrace.
 *
 * While authors could explicitly create these in principle, the intention is
 * to generate them automatically when compiling jsx. The compilation process
 * only inserts `StacktracingExpressions` for macro invocations in the author's
 * code, but not for macro invocations that are mere implementation details of
 * other macros. The resulting stacktraces are thus meaningful to the author,
 * whereas implementation details of macros stay hidden.
 */
export class StacktracingExpression {
  /**
   * The wrapped {@linkcode Expression}.
   */
  public exp: Expression;
  /**
   * Debugging information pertaining to the wrapped {@linkcode Expression}.
   */
  public info: DebuggingInformation;

  /**
   * @param exp The {@linkcode Expression} to wrap.
   * @param info {@linkcode DebuggingInformation} regarding {@linkcode exp}.
   */
  constructor(
    exp: Expression,
    info: DebuggingInformation,
  ) {
    this.exp = exp;
    this.info = info;
  }
}

/**
 * Shared state during an evaluation that can be freely used by macros.
 *
 * The itention is for macro authors to keep the symbols they use private, and
 * to export strongly typed functions for interacting with their parts of the
 * state instead.
 */
// deno-lint-ignore no-explicit-any
export type State = Map<symbol, any>;

// Global flag to track whether we are currently evaluating or not.
// While evaluating, do not wrap jsx macros with StacktracingExpressions.
let currentlyEvaluating = false;

// Throwing the following symbol immediately terminates evaluation. This value
// is not exposed, it is an implementation detail of `Context.halt()`.
const haltEvaluation = Symbol("Halt Evaluation");

/**
 * The state that is threaded through an evaluation process.
 *
 * The functions of {@linkcode DelayedExpression},
 * {@linkcode LifecyclingExpression}, and{@linkcode MappingExpression} can
 * access the `Context`.
 */
export class Context {
  // The shared mutable state.
  private state: State;
  // Like a callstack, but for the DebuggingInformation of
  // StacktracingExpressions.
  private stack: Stack<DebuggingInformation>;
  // True if no DelayingExpression making progress would terminate expansion.
  private haveToMakeProgress: boolean;
  // Count the number of evaluation rounds.
  private round: number;
  // To determine whether `have_to_make_progress` needs to be set after an
  // evaluation round, we track whether at least one DelayedExpression has made
  // progress in the current round.
  private madeProgressThisRound: boolean;
  // The Context provides several methods for logging. This field provides the
  // backend for the logging methods.
  private console: Console;

  /**
   * Create a new `Context`, logging to the given `Console`.
   * @param console_ The `Console` to use for the logging methods on `Context`.
   * Defaults to the global console.
   */
  constructor(console_?: Console) {
    this.state = new Map();
    this.stack = new_stack();
    this.haveToMakeProgress = false;
    this.round = 0;
    this.madeProgressThisRound = false;
    this.console = console_ ? console_ : console /*the global typescript one*/;
  }

  /**
   * @returns The {@linkcode State} for this evaluation.
   */
  public getState(): State {
    return this.state;
  }

  /**
   * @returns A stack of all the {@linkcode DebuggingInformation} of all
   * ancestor {@linkcode StacktracingExpression}s of the currently evaluated
   * expression.
   */
  public getDebuggingStack(): Stack<DebuggingInformation> {
    return this.stack;
  }

  /**
   * @returns The {@linkcode DebuggingInformation} of the
   * {@linkcode StacktracingExpression} closest to the currently evaluated
   * expression. An empty object if there is none.
   */
  public getCurrentDebuggingInformation(): DebuggingInformation {
    return this.stack.peek() ?? {};
  }

  /**
   * When no {@linkcode DelayedExpression} makes progress in an evaluation
   * round, another round is started, in which this function returns `true`.
   * If no {@linkcode DelayedExpression} makes progress in that round either,
   * evaluation stops.
   *
   * @returns `true` if progress must be made, `false` otherwise.
   */
  public mustMakeProgress(): boolean {
    return this.haveToMakeProgress;
  }

  /**
   * @returns The current evaluation round number.
   */
  public getRound(): number {
    return this.round;
  }

  /**
   * Log trace-level output.
   */
  // deno-lint-ignore no-explicit-any
  public trace(...data: any[]): void {
    this.console.info(Colors.dim("[trace]"), ...data);
  }

  /**
   * Log trace-level output, annotated with the current
   * {@linkcode DebuggingInformation}.
   */
  // deno-lint-ignore no-explicit-any
  public trace_at(...data: any[]): void {
    this.console.info(
      Colors.dim("[trace]"),
      ...data,
      "at",
      formatDebuggingInformation(this.getCurrentDebuggingInformation()),
    );
  }

  /**
   * Log informational output.
   */
  // deno-lint-ignore no-explicit-any
  public info(...data: any[]): void {
    this.console.info(Colors.blue("[info]"), ...data);
  }

  /**
   * Log informational output, annotated with the current
   * {@linkcode DebuggingInformation}.
   */
  // deno-lint-ignore no-explicit-any
  public info_at(...data: any[]): void {
    this.console.info(
      Colors.green("[info]"),
      ...data,
      "at",
      formatDebuggingInformation(this.getCurrentDebuggingInformation()),
    );
  }

  /**
   * Log a warning.
   */
  // deno-lint-ignore no-explicit-any
  public warn(...data: any[]): void {
    this.console.warn(Colors.yellow("[warn]"), ...data);
  }

  /**
   * Log a warning, annotated with the current
   * {@linkcode DebuggingInformation}.
   */
  // deno-lint-ignore no-explicit-any
  public warn_at(...data: any[]): void {
    this.console.warn(
      Colors.yellow("[warn]"),
      ...data,
      "at",
      formatDebuggingInformation(this.getCurrentDebuggingInformation()),
    );
  }

  /**
   * Log an error.
   */
  // deno-lint-ignore no-explicit-any
  public error(...data: any[]): void {
    this.console.error(Colors.red("[err]"), ...data);
  }

  /**
   * Log an error, annotated with the current {@linkcode DebuggingInformation}.
   */
  // deno-lint-ignore no-explicit-any
  public error_at(...data: any[]): void {
    this.console.warn(
      Colors.red("[err]"),
      ...data,
      "at",
      formatDebuggingInformation(this.getCurrentDebuggingInformation()),
    );
  }

  /**
   * Print a stacktrace, then immediately and faultily terminate evaluation.
   */
  public halt(): void {
    // Print a stacktrace of the user-facing macros that lead to the failure.
    this.console.group("");
    let stack = this.stack;
    while (!stack.is_empty()) {
      this.console.log("at", formatDebuggingInformation(stack.peek()!));
      stack = stack.pop();
    }
    this.console.groupEnd();

    // Caught in `evaluate`, never leaks.
    throw haltEvaluation;
  }

  // Time to implement Expression evaluation. Given an Expression, either successfully
  // evaluates it into a string, or returns `null` to indicate a failure (either because
  // of a call to `halt`, or because expansion did not progress two attempts in a row).
  public evaluate(expression: Expression): string | null {
    // To exclude macro-generated macro invocations from user-facing debugging logging,
    // we set the currently_debugging flag.
    currently_evaluating = true;

    // We catch any thrown `halt_evaluation` values (the only way this happens is
    // through calling `halt`).
    try {
      // Evaluation proceeds in a loop. Try to evaluate the toplevel expression. If it
      // was completely turned into a string, return that string. Otherwise, take the
      // resulting non-string expression and try evaluating it again.
      let exp = expression;
      while (typeof exp != "string") {
        // Do an evaluation round. We will see shortly what that looks like.
        exp = this.do_evaluate(exp);

        // If evaluation made no progress at all, we set a macro-readable flag so that
        // the macros try their best to make progress. If that flag had been set already,
        // then clearly the macros are not going to cooporate, so we stop the evaluation.
        if (this.madeProgressThisRound) {
          if (this.haveToMakeProgress) {
            // Log the macros that should have made progress but did not, causing
            // evaluation to give up.
            this.log_active_leaves(exp);
            return null;
          } else {
            this.haveToMakeProgress = true;
          }
        }

        // The evaluation round has completed, increase the round counter and reset the
        // `made_progress_this_round` flag.
        this.round += 1;
        this.madeProgressThisRound = false;

        // And then back to the top of the loop, attempting to evaluate again.
      }

      // End of the evaluation loop. We managed to covert the initial Expression
      // into a string, so we proudly return it (but not after updating the global
      // flag to indicate we are not evaluating anymore).
      currently_evaluating = false;

      return exp;
    } catch (err) {
      // Evaluation has defnitely ended, regardless of which value was thrown.
      currently_evaluating = false;

      // If the thrown value was `halt_evaluation`, we return `null` to cleanly indicate
      // evaluaton failure. All other exceptions are indeed exceptional and are simply
      // rethrown.
      if (err === halt_evaluation) {
        return null;
      } else {
        throw err;
      }
    }
  }

  // Now for the actual meat of the evaluator: doing an evaluation round, that is,
  // progressing evaluation of an Expression as much as possible.
  private do_evaluate(exp: Expression): Expression {
    // Evaluation works differently based on the kind of Expression.
    if (typeof exp === "string") {
      // Strings evaluate to themselves
      return exp;
    } else if (Array.isArray(exp)) {
      // Evaluate arrays by successively evaluating their items. Join together
      // adjacent strings to prevent unncecessarily iterating over them separately
      // in future evaluation rounds.
      const evaluated: Expression = [];
      let previous_evaluated_to_string = false;
      for (const inner of exp) {
        const inner_evaluated = this.do_evaluate(inner);

        if (typeof inner_evaluated === "string") {
          if (previous_evaluated_to_string) {
            evaluated[evaluated.length - 1] =
              (<string> evaluated[evaluated.length - 1]).concat(
                inner_evaluated,
              );
          } else {
            previous_evaluated_to_string = true;
            evaluated.push(inner_evaluated);
          }
        } else {
          evaluated.push(inner_evaluated);
        }
      }

      // Further simplify the array of evaluated expressions if possible,
      // otherwise return it directly.
      if (evaluated.length === 0) {
        return "";
      } else if (evaluated.length === 1) {
        return evaluated[0];
      } else {
        return evaluated;
      }
    } else if (exp instanceof Invocation) {
      // Evaluate an Invocation by calling the invocation function.
      // Before calling it, we update the stack trace, if the Invocation was
      // user-created.
      if (exp.src) {
        this.stack = this.stack.push(exp.src);
      }
      const invoked = exp.fun(this);

      // Done invoking, so pop the Invocation from the stacktrace again.
      if (exp.src) {
        this.stack = this.stack.pop(exp.src);
      }

      if (invoked instanceof WipExpansion) {
        // If the invocation was successful, we made progress.
        this.madeProgressThisRound = true;
        // We then continue by trying to evaluate the fresh WipExpansion, after
        // setting its SourceLocation to that of its spawning Invocation.
        invoked.src = exp.src;
        return this.do_evaluate(invoked);
      } else {
        // Otherwise we have to retry evaluating the same Invocation again next round.
        return exp;
      }
    } else if (exp instanceof WipExpansion) {
      // To evaluate a WipExpression, we
      //    - update the call stack, then
      //    - call its pre_evaluate lifecycle function, then
      //    - evaluate its `exp`, then
      //    - call its post_evaluate lifecycle function, and finally
      //    - map the evaluation result through `finalize` if it was a string.

      if (exp.src) {
        this.stack = this.stack.push(exp.src);
      }

      exp.pre_evaluate(this);
      const evaluated = this.do_evaluate(exp.exp);
      exp.post_evaluate(this);

      // We are now done with the WipExpansion for this round, whether successful or not.
      if (exp.src) {
        this.stack = this.stack.pop(exp.src);
      }

      if (typeof evaluated === "string") {
        // The WipExpansion is fully done, so we finalize. If the result is an Invocation
        // or another WipExpansion, it takes on the SourceLocation of the original.
        const finalized = exp.finalize(evaluated, this);
        if (
          finalized instanceof Invocation || finalized instanceof WipExpansion
        ) {
          finalized.src = exp.src;
        }

        // Evaluation continues by substituting the result of `finalize` for the
        // WipExpression.
        return this.do_evaluate(finalized);
      } else {
        // Did not finish the WipEvaluation, try again next round.
        return exp;
      }
    } else {
      // If typescript had a moderately sensible type system, this case would be unreachable.
      throw new Error(`Tried to evaluate a value that is not an Expression.
Someone somewhere did type-system shenanigans that went wrong.

${exp}`);
    }
  }

  // When evaluation halts because no macro makes any progress, we log the offending
  // macros. More precisely, we log all Invocations and the WipExpansions whose
  // expression is a string (all other WipExpansions are blocked from making progress
  // by subexpressions).
  log_active_leaves(exp: Expression) {
    // Prepare for logging, then call a recursive subroutine to do the actual work.
    this.console.group("Evaluation was blocked by:");
    this.log_active_leaves_(exp);
    this.console.groupEnd();
  }

  log_active_leaves_(exp: Expression) {
    if (typeof exp === "string") {
      // Do nothing with strings, strings do not block evaluation.
    } else if (Array.isArray(exp)) {
      // Log the leaves of all subexpressions.
      exp.forEach((child) => this.log_active_leaves_(child));
    } else if (exp instanceof Invocation) {
      // Any unresolved invocations have blocked expansion.
      this.console.log(format_location(exp.src));
    } else if (exp instanceof WipExpansion) {
      if (typeof exp.exp === "string") {
        this.console.log(format_location(exp.src));
      } else {
        this.log_active_leaves_(exp.exp);
      }
    }
  }
}

// export function new_macro(
//   expand: (args: Argument[], ctx: Context) => (Expression | null) = default_expand,
//   finalize: (expanded: string, ctx: Context) => (string | null) = default_finalize,
//   td: (ctx: Context) => void = default_td,
//   bu: (ctx: Context) => void = default_bu,
//   offset = 1,
// ): Macro {
//   if (!currently_evaluating) {
//     const macro_def = getCurrentLine({frames: 1 + offset});
//     const callsite = getCurrentLine({frames: 2 + offset});
//     callsite.method = macro_def.method;
//     return new Macro(expand, td, bu, finalize, callsite);
//   } else {
//     return new Macro(expand, td, bu, finalize, undefined);
//   }
// }

// export function default_expand(args: Argument[], _ctx: Context): Expression {
//   return args;
// }

// export function default_td(_ctx: Context) {
//   return;
// }

// export function default_bu(_ctx: Context) {
//   return;
// }

// export function default_finalize(expanded: string, _ctx: Context): string {
//   return expanded;
// }

// // Considers every array as an expression
// // deno-lint-ignore no-explicit-any
// export function is_expression(x: any): boolean {
//   if (typeof x === "function") {
//     return true;
//   } else if (x === -1) {
//     return true;
//   } else if (typeof x === "string") {
//     return true;
//   } else if (Array.isArray(x)) {
//     return true;
//   } else if (x instanceof Invocation || x instanceof ExpandedMacro || x instanceof Argument) {
//     return true;
//   } else {
//     return false;
//   }
// }

// export function surpress_output(
//   ...exps: Expression[]
// ): Expression {
//   const macro = new_macro(
//     undefined,
//     (_, _ctx) => "",
//     );

//   return new Invocation(macro, exps);
// }

// export interface SourceLocation {
//   file_name: string,
//   line_number: number,
//   column_number: number,
//   macro_name: string,
// }

// // Prett formatting for SourceLocations
// export function format_location(src: SourceLocation): string {
//   return `${Colors.bold(Colors.italic(src.macro_name))} in ${style_file(src.file_name)}${Colors.yellow(`:${src.line_number}:${src.column_number}`)}`;
// }

// export function style_file(s: string): string {
//   return Colors.cyan(s);
// }
